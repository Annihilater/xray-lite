use bytes::{BufMut, BytesMut};

/// 生成一个最小的自签名证书（用于测试）
pub fn generate_dummy_certificate() -> Vec<u8> {
    // 这是一个最小的 X.509 证书结构
    // 实际上这只是一个占位符，真实环境应该使用真实证书
    let mut cert = BytesMut::new();

    // Certificate Handshake Message
    cert.put_u8(11); // Type: Certificate

    // 预留长度位置
    let len_pos = cert.len();
    cert.put_u8(0);
    cert.put_u8(0);
    cert.put_u8(0);

    // Certificate Request Context (empty for server)
    cert.put_u8(0);

    // Certificate List Length (预留)
    let list_len_pos = cert.len();
    cert.put_u8(0);
    cert.put_u8(0);
    cert.put_u8(0);

    // 单个证书条目
    // Certificate Length
    let cert_data = create_minimal_x509();
    cert.put_u8(((cert_data.len() >> 16) & 0xFF) as u8);
    cert.put_u8(((cert_data.len() >> 8) & 0xFF) as u8);
    cert.put_u8((cert_data.len() & 0xFF) as u8);
    cert.put_slice(&cert_data);

    // Extensions Length (empty)
    cert.put_u16(0);

    // 回填 Certificate List Length
    let list_len = cert.len() - list_len_pos - 3;
    cert[list_len_pos] = ((list_len >> 16) & 0xFF) as u8;
    cert[list_len_pos + 1] = ((list_len >> 8) & 0xFF) as u8;
    cert[list_len_pos + 2] = (list_len & 0xFF) as u8;

    // 回填总长度
    let total_len = cert.len() - len_pos - 3;
    cert[len_pos] = ((total_len >> 16) & 0xFF) as u8;
    cert[len_pos + 1] = ((total_len >> 8) & 0xFF) as u8;
    cert[len_pos + 2] = (total_len & 0xFF) as u8;

    cert.to_vec()
}

/// 创建一个最小的 X.509 证书（DER 编码）
fn create_minimal_x509() -> Vec<u8> {
    // 这是一个硬编码的最小自签名证书
    // 在生产环境中应该使用 rcgen 或类似库生成
    vec![
        0x30, 0x82, 0x01, 0x22, // SEQUENCE
        0x30, 0x81, 0xCF, // TBSCertificate SEQUENCE
        0xA0, 0x03, 0x02, 0x01, 0x02, // Version
        0x02, 0x01, 0x01, // Serial Number
        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05,
        0x00, // Signature Algorithm
        0x30, 0x12, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x07, 0x52, 0x65,
        0x61, 0x6C, 0x69, 0x74, 0x79, // Issuer
        0x30, 0x1E, 0x17, 0x0D, 0x32, 0x34, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
        0x30, 0x5A, 0x17, 0x0D, 0x32, 0x35, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
        0x30, 0x5A, // Validity
        0x30, 0x12, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x07, 0x52, 0x65,
        0x61, 0x6C, 0x69, 0x74, 0x79, // Subject
        0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08,
        0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, // Public Key Algorithm
        0x03, 0x42, 0x00, 0x04, // Public Key
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01,
        0x01, 0x0B, 0x05, 0x00, // Signature Algorithm
        0x03, 0x41, 0x00, // Signature
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ]
}

/// 生成 CertificateVerify 消息
pub fn generate_certificate_verify(transcript_hash: &[u8]) -> Vec<u8> {
    let mut cv = BytesMut::new();

    cv.put_u8(15); // Type: CertificateVerify

    // Signature Algorithm: rsa_pss_rsae_sha256 (0x0804)
    let signature = create_dummy_signature(transcript_hash);

    let body_len = 2 + 2 + signature.len();
    cv.put_u8(((body_len >> 16) & 0xFF) as u8);
    cv.put_u8(((body_len >> 8) & 0xFF) as u8);
    cv.put_u8((body_len & 0xFF) as u8);

    cv.put_u16(0x0804); // Algorithm
    cv.put_u16(signature.len() as u16);
    cv.put_slice(&signature);

    cv.to_vec()
}

fn create_dummy_signature(_transcript_hash: &[u8]) -> Vec<u8> {
    // 创建一个虚拟签名（64字节）
    vec![0u8; 64]
}
